<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link
      rel="icon"
      type="image/svg+xml"
      href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZmlsbD0iIzI5NjJmZiIgZD0iTTE5LDNINWMtMS4xLDAtMiwwLjktMiwydjE0YzAsMS4xLDAuOSwyLDIsMmgxNGMxLjEsMCwyLTAuOSwyLTJWNUMyMSwzLjksMjAuMSwzLDE5LDN6IE0xNywxM2gtNHY0aC0ydi00SDd2LTJoNFY3aDJ2NGg0VjEzeiIvPjwvc3ZnPg=="
    />
    <title>Quick Note</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;500&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg-color: #ffffff;
        --text-color: #333333;
        --toolbar-bg: #f0f0f0;
        --button-bg: #e0e0e0;
        --button-hover: #d0d0d0;
        --error-color: #ff4444;
        --json-string: #22863a;
        --json-number: #005cc5;
        --json-boolean: #d73a49;
        --json-null: #6f42c1;
        --json-key: #24292e;
      }

      [data-theme="dark"] {
        --bg-color: #1a1a1a;
        --text-color: #ffffff;
        --toolbar-bg: #2d2d2d;
        --button-bg: #3d3d3d;
        --button-hover: #4d4d4d;
        --error-color: #ff6666;
        --json-string: #85e89d;
        --json-number: #79b8ff;
        --json-boolean: #f97583;
        --json-null: #b392f0;
        --json-key: #e1e4e8;
      }

      /* API key section styles */
      .api-section {
        display: flex;
        align-items: center;
        gap: 5px;
        margin-left: auto;
      }

      .api-key-container {
        display: none;
        align-items: center;
        gap: 5px;
      }

      .api-key-container.visible {
        display: flex;
      }

      .api-key-input {
        padding: 8px;
        border-radius: 4px;
        border: 1px solid var(--button-bg);
        background-color: var(--bg-color);
        color: var(--text-color);
        font-family: "Rubik", sans-serif;
        width: 260px;
      }

      .loading-spinner {
        display: none;
        width: 16px;
        height: 16px;
        border: 2px solid var(--button-bg);
        border-top: 2px solid var(--text-color);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-left: 5px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        margin: 0;
        padding: 20px;
        background-color: var(--bg-color);
        color: var(--text-color);
        font-family: "Rubik", sans-serif;
        transition: background-color 0.3s, color 0.3s;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      .editor-container {
        width: 100%; /* Change from fixed width to 100% */
        max-width: 1200px; /* Maximum width */
        margin: 0 auto;
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        height: 100%; /* Add this */
        position: relative; /* Add this */
      }

      .toolbar {
        background-color: var(--toolbar-bg);
        padding: 10px;
        border-radius: 5px 5px 0 0;
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
        position: sticky;
        top: 0;
        transform: translateY(-100%);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 1000;
        opacity: 0;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(8px);
        border-bottom: 1px solid var(--button-bg);
      }

      .toolbar.visible {
        transform: translateY(0);
        opacity: 1;
      }

      .editor-container::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 10px; /* Reduced height for more subtle interaction */
        z-index: 999;
      }

      .button {
        padding: 8px 12px;
        border: none;
        border-radius: 4px;
        background-color: var(--button-bg);
        color: var(--text-color);
        cursor: pointer;
        transition: background-color 0.2s;
        font-family: "Rubik", sans-serif;
        transition: background-color 0.2s ease, transform 0.1s ease;
      }

      .button:hover {
        background-color: var(--button-hover);
        transform: translateY(-1px);
      }

      .button:active {
        transform: translateY(0px);
      }

      .button.error {
        animation: shake 0.5s;
      }

      @keyframes shake {
        0%,
        100% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-5px);
        }
        75% {
          transform: translateX(5px);
        }
      }

      #editor,
      #formatted-display {
        width: 100%;
        flex-grow: 1;
        padding: 15px;
        border: 1px solid var(--button-bg);
        border-radius: 0 0 5px 5px;
        background-color: var(--bg-color);
        color: var(--text-color);
        resize: none;
        font-family: "Rubik", monospace;
        min-height: calc(100vh - 140px);
        tab-size: 2;
        white-space: pre-wrap; /* Preserves spaces and line breaks but wraps text */
        word-wrap: break-word; /* Breaks long words to prevent overflow */
        overflow-wrap: break-word;
        line-height: 1.5;
        resize: none;
        overflow-y: auto;
        box-sizing: border-box;
        min-height: calc(100vh - 140px);
        cursor: pointer;
            display: none; /
      }

      /* Add responsive adjustments */
      @media (max-width: 1024px) {
        .editor-container {
          padding: 0 10px; /* Add some padding on smaller screens */
        }
      }

      #editor:focus {
        outline: none;
        border-color: var(--button-bg);
      }

      .font-size-controls {
        display: flex;
        align-items: center;
        gap: 5px;
      }

      #fontSize {
        width: 50px;
        padding: 5px;
        border-radius: 4px;
        border: 1px solid var(--button-bg);
        background-color: var(--bg-color);
        color: var(--text-color);
        font-family: "Rubik", sans-serif;
      }

      .status-bar {
        margin-top: 10px;
        font-size: 0.9em;
        color: var(--text-color);
        opacity: 0.8;
        padding: 5px 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      #formatStatus {
        color: var(--error-color);
        opacity: 0;
        transition: opacity 0.3s;
      }

      #formatStatus.show {
        opacity: 1;
      }

      .spellcheck-toggle {
        display: flex;
        align-items: center;
        gap: 5px;
        user-select: none;
      }

      .spellcheck-toggle input {
        margin: 0;
      }

      #formatted-display {
        cursor: pointer;
      }
      #formatted-display::after {
        content: "(Click to edit)";
        display: block;
        font-size: 12px;
        color: var(--text-color);
        opacity: 0.7;
        margin-top: 10px;
      }

      #formatted-display.show-edit-hint::after {
            content: "(Click to edit)";
            display: block;
            font-size: 12px;
            color: var(--text-color);
            opacity: 0.7;
            margin-top: 10px;
        }

      .json-string {
        color: var(--json-string);
      }
      .json-number {
        color: var(--json-number);
      }
      .json-boolean {
        color: var(--json-boolean);
      }
      .json-null {
        color: var(--json-null);
      }
      .json-key {
        color: var(--json-key);
      }

      .export-dropdown {
        position: relative;
        display: inline-block;
      }

      .export-menu {
        display: none;
        position: absolute;
        background-color: var(--bg-color);
        border: 1px solid var(--button-bg);
        border-radius: 4px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        min-width: 160px;
      }

      .export-menu.show {
        display: block;
      }

      .export-item {
        padding: 8px 12px;
        cursor: pointer;
        transition: background-color 0.2s;
      }

      .export-item:hover {
        background-color: var(--button-hover);
      }

      .export-item.disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      /* Toast notification styles */
      .toast {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background-color: var(--bg-color);
        color: var(--text-color);
        padding: 12px 24px;
        border-radius: 4px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        display: none;
        z-index: 1000;
        border: 1px solid var(--button-bg);
      }

      .toast.show {
        display: block;
        animation: slideIn 0.3s, slideOut 0.3s 2.7s;
      }

      @keyframes slideIn {
        from {
          transform: translateX(100%);
        }
        to {
          transform: translateX(0);
        }
      }

      @keyframes slideOut {
        from {
          transform: translateX(0);
        }
        to {
          transform: translateX(100%);
        }
      }

      /* Add styles for theme toggle */
      .theme-toggle {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1001;
        background: none;
        border: none;
        cursor: pointer;
        padding: 8px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s;
        background-color: var(--button-bg);
        width: 40px;
        height: 40px;
      }

      .theme-toggle:hover {
        background-color: var(--button-hover);
      }

      .theme-toggle svg {
        width: 20px;
        height: 20px;
        fill: none;
        stroke: var(--text-color);
        stroke-width: 2;
        stroke-linecap: round;
        stroke-linejoin: round;
        transition: transform 0.3s ease;
      }

      .theme-toggle:hover svg {
        transform: rotate(45deg);
      }

      /* SVG definitions for moon and sun icons */
      .sun-icon {
        display: none;
      }

      [data-theme="dark"] .moon-icon {
        display: none;
      }

      [data-theme="dark"] .sun-icon {
        display: block;
      }
    </style>
  </head>
  <body>
    <div class="editor-container">
      <div class="toolbar">
        <button class="button" id="formatJSON">Format JSON</button>
        <button class="button" id="convertTimestamp">Convert Timestamp</button>
        <button class="button" id="improveText">Improve Text</button>
        <div class="export-dropdown">
          <button class="button" id="exportButton">Export</button>
          <div class="export-menu" id="exportMenu">
            <div class="export-item" id="exportMd">
              Export as Markdown (.md)
            </div>
            <div class="export-item" id="exportJson">
              Export as JSON (.json)
            </div>
          </div>
        </div>
        <div class="font-size-controls">
          <label for="fontSize">Font Size:</label>
          <input type="number" id="fontSize" value="17" min="12" max="25" />
          <span>px</span>
        </div>
        <div class="spellcheck-toggle">
          <input type="checkbox" id="spellcheckToggle" />
          <label for="spellcheckToggle">Spell Check</label>
        </div>
        <div class="api-section">
          <button class="button" id="apiKeyToggle">ðŸ”‘</button>
          <div class="api-key-container" id="apiKeyContainer">
            <input
              type="password"
              class="api-key-input"
              id="apiKey"
              placeholder="Enter OpenAI API Key"
            />
            <div class="loading-spinner" id="loadingSpinner"></div>
          </div>
        </div>
      </div>
      <textarea id="editor" spellcheck="false"></textarea>
      <pre id="formatted-display"></pre>
      <div class="status-bar">
        <div>Words: <span id="wordCount">0</span></div>
        <div id="formatStatus"></div>
      </div>

      <div class="toast" id="toast"></div>
    </div>

    <!-- Add new theme toggle button -->
    <button class="theme-toggle" id="themeToggle" aria-label="Toggle theme">
      <svg class="moon-icon" viewBox="0 0 24 24">
        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
      </svg>
      <svg class="sun-icon" viewBox="0 0 24 24">
        <circle cx="12" cy="12" r="5"></circle>
        <line x1="12" y1="1" x2="12" y2="3"></line>
        <line x1="12" y1="21" x2="12" y2="23"></line>
        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
        <line x1="1" y1="12" x2="3" y2="12"></line>
        <line x1="21" y1="12" x2="23" y2="12"></line>
        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
      </svg>
    </button>

    <script>
      const themeToggle = document.getElementById("themeToggle");
      const fontSizeInput = document.getElementById("fontSize");
      const editor = document.getElementById("editor");
      const formattedDisplay = document.getElementById("formatted-display");
      const wordCountElement = document.getElementById("wordCount");
      const formatJSONButton = document.getElementById("formatJSON");
      const formatStatus = document.getElementById("formatStatus");
      const spellcheckToggle = document.getElementById("spellcheckToggle");
      const convertTimestampButton =
        document.getElementById("convertTimestamp");

      const apiKeyToggle = document.getElementById("apiKeyToggle");
      const apiKeyContainer = document.getElementById("apiKeyContainer");
      const apiKeyInput = document.getElementById("apiKey");
      const improveTextButton = document.getElementById("improveText");
      const loadingSpinner = document.getElementById("loadingSpinner");

      // Load saved API key
      apiKeyInput.value = localStorage.getItem("openaiApiKey") || "";

      // Toggle API key input visibility
      apiKeyToggle.addEventListener("click", () => {
        apiKeyContainer.classList.toggle("visible");
      });

      // Save API key
      apiKeyInput.addEventListener("change", (e) => {
        localStorage.setItem("openaiApiKey", e.target.value);
      });

      // Improve text using OpenAI API
      improveTextButton.addEventListener("click", async () => {
        const apiKey = apiKeyInput.value.trim();
        const text = editor.value.trim();

        if (!apiKey) {
          formatStatus.textContent = "Please enter an API key";
          formatStatus.style.color = "var(--error-color)";
          formatStatus.classList.add("show");
          apiKeyContainer.classList.add("visible");
          return;
        }

        if (!text) {
          formatStatus.textContent = "Please enter some text";
          formatStatus.style.color = "var(--error-color)";
          formatStatus.classList.add("show");
          return;
        }

        loadingSpinner.style.display = "inline-block";
        improveTextButton.disabled = true;

        try {
          const response = await fetch(
            "https://api.openai.com/v1/chat/completions",
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${apiKey}`,
              },
              body: JSON.stringify({
                model: "gpt-4o",
                messages: [
                  {
                    role: "system",
                    content:
                      "Your task is to take the text provided and rewrite it into a clear, grammatically correct version while preserving the original meaning as closely as possible. Correct any spelling mistakes, punctuation errors, verb tense issues, word choice problems, and other grammatical mistakes.Only give me the improvement text.",
                  },
                  {
                    role: "user",
                    content: text,
                  },
                ],
              }),
            }
          );

          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error?.message || "API request failed");
          }

          const data = await response.json();
          const improvedText = data.choices[0].message.content;

          editor.value = `${text}\n\n====================================================\n\n${improvedText}`;
          updateWordCount();

          formatStatus.textContent = "Text improved successfully";
          formatStatus.style.color = "var(--text-color)";
          formatStatus.classList.add("show");
        } catch (error) {
          console.error("Error:", error);
          formatStatus.textContent = "Error: " + error.message;
          formatStatus.style.color = "var(--error-color)";
          formatStatus.classList.add("show");
        } finally {
          loadingSpinner.style.display = "none";
          improveTextButton.disabled = false;
          setTimeout(() => {
            formatStatus.classList.remove("show");
          }, 2000);
        }
      });

      let isFormatted = false;

      // JSON syntax highlighting function
      function highlightJSON(json) {
        return json.replace(
          /("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g,
          function (match) {
            let cls = "json-number";
            if (/^"/.test(match)) {
              if (/:$/.test(match)) {
                cls = "json-key";
                match =
                  match.slice(0, -1) +
                  '<span style="color: var(--text-color)">:</span>';
              } else {
                cls = "json-string";
              }
            } else if (/true|false/.test(match)) {
              cls = "json-boolean";
            } else if (/null/.test(match)) {
              cls = "json-null";
            }
            return '<span class="' + cls + '">' + match + "</span>";
          }
        );
      }

      // Toggle between raw and formatted views
      // Update the toggleView function
      function toggleView() {
        if (isFormatted) {
          editor.style.display = "none";
          formattedDisplay.style.display = "block";
          formattedDisplay.classList.add("show-edit-hint"); // Add class only when showing formatted view
        } else {
          editor.style.display = "block";
          formattedDisplay.style.display = "none";
          formattedDisplay.classList.remove("show-edit-hint"); // Remove class when showing editor
        }
      }

      // Initialize the view
      isFormatted = false;
      toggleView();

      // Add a new event listener for the formatted display to handle clicks
      formattedDisplay.addEventListener("click", () => {
        isFormatted = false;
        editor.value = formattedDisplay.textContent; // Copy content without HTML formatting
        toggleView();
        editor.focus(); // Focus on the editor for immediate typing
      });

      // Update the formatJSON button click handler
      formatJSONButton.addEventListener("click", () => {
        const text = editor.value.trim();
        if (!text) return;

        try {
          const parsed = JSON.parse(text);
          const formatted = JSON.stringify(parsed, null, 2);
          editor.value = formatted;
          formattedDisplay.innerHTML = highlightJSON(formatted);

          isFormatted = true;
          toggleView();

          formatStatus.textContent =
            "JSON formatted successfully (click to edit)";
          formatStatus.style.color = "var(--text-color)";
          formatStatus.classList.add("show");

          setTimeout(() => {
            formatStatus.classList.remove("show");
          }, 2000);
        } catch (error) {
          formatStatus.textContent = "Invalid JSON";
          formatStatus.style.color = "var(--error-color)";
          formatStatus.classList.add("show");
          formatJSONButton.classList.add("error");

          setTimeout(() => {
            formatJSONButton.classList.remove("error");
            formatStatus.classList.remove("show");
          }, 2000);
        }
      });

      // Add cursor style to formatted display
      formattedDisplay.style.cursor = "pointer";

      // Update font size for both views
      fontSizeInput.addEventListener("input", (e) => {
        const size = e.target.value;
        if (size >= 8 && size <= 72) {
          editor.style.fontSize = `${size}px`;
          formattedDisplay.style.fontSize = `${size}px`;
        }
      });

      // Set initial font size
      editor.style.fontSize = `${fontSizeInput.value}px`;
      formattedDisplay.style.fontSize = `${fontSizeInput.value}px`;

      // Theme toggle functionality
      // Function to set theme
      function setTheme(isDark) {
        document.documentElement.setAttribute(
          "data-theme",
          isDark ? "dark" : "light"
        );
        localStorage.setItem("theme", isDark ? "dark" : "light");
      }

      // Initialize theme from localStorage
      document.addEventListener("DOMContentLoaded", () => {
        const savedTheme = localStorage.getItem("theme") || "light";
        setTheme(savedTheme === "dark");
      });

      // Theme toggle click handler
      themeToggle.addEventListener("click", () => {
        const currentTheme =
          document.documentElement.getAttribute("data-theme");
        setTheme(currentTheme !== "dark");
      });

      // Word count functionality
      function updateWordCount() {
        const text = editor.value.trim();
        const wordCount = text ? text.split(/\s+/).length : 0;
        wordCountElement.textContent = wordCount;
      }

      editor.addEventListener("input", () => {
        updateWordCount();
        isFormatted = false;
        toggleView();
      });

      // Initial word count
      updateWordCount();

      // Add this event listener after your other event listeners in the script section
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          editor.value = "";
          formattedDisplay.innerHTML = "";
          isFormatted = false;
          toggleView();
          updateWordCount();
          formatStatus.textContent = "Text cleared";
          formatStatus.style.color = "var(--text-color)";
          formatStatus.classList.add("show");

          setTimeout(() => {
            formatStatus.classList.remove("show");
          }, 2000);
        }
      });

      // Spell check toggle functionality
      spellcheckToggle.addEventListener("change", (e) => {
        editor.spellcheck = e.target.checked;
      });

      // Timestamp conversion functionality
      convertTimestampButton.addEventListener("click", () => {
        const text = editor.value.trim();
        if (!text) return;

        try {
          const timestamp = parseInt(text);
          if (isNaN(timestamp)) throw new Error("Invalid timestamp");

          const format =
            timestamp.toString().length === 13 ? "milliseconds" : "seconds";
          const ms = format === "seconds" ? timestamp * 1000 : timestamp;
          const date = new Date(ms);

          if (date.toString() === "Invalid Date")
            throw new Error("Invalid timestamp");

          const result = `\n\nFormat detected: ${format}\n\nUTC: ${date.toUTCString()}\n\nYour time zone: ${date.toString()}`;

          isFormatted = false;
          toggleView();

          const currentPosition = editor.selectionStart;
          const beforeText = editor.value.substring(0, currentPosition);
          const afterText = editor.value.substring(currentPosition);
          editor.value = beforeText + result + afterText;

          updateWordCount();
        } catch (error) {
          formatStatus.textContent = "Invalid timestamp";
          formatStatus.style.color = "var(--error-color)";
          formatStatus.classList.add("show");
          convertTimestampButton.classList.add("error");

          setTimeout(() => {
            convertTimestampButton.classList.remove("error");
            formatStatus.classList.remove("show");
          }, 2000);
        }
      });

      // Add this JavaScript
      const toolbar = document.querySelector(".toolbar");

      // Show toolbar on hover at top or when toolbar itself is hovered
      function handleToolbarVisibility() {
        let timeoutId;

        // Show toolbar when mouse is near top of screen
        document.addEventListener("mousemove", (e) => {
          if (e.clientY < 20) {
            // Mouse is within 20px of top
            toolbar.classList.add("visible");
            clearTimeout(timeoutId);
          }
        });

        // Handle toolbar hover
        toolbar.addEventListener("mouseenter", () => {
          toolbar.classList.add("visible");
          clearTimeout(timeoutId);
        });

        // Handle mouse leave
        toolbar.addEventListener("mouseleave", (e) => {
          // Only hide if mouse isn't near top of screen
          if (e.clientY > 20) {
            timeoutId = setTimeout(() => {
              toolbar.classList.remove("visible");
            }, 1000); // Delay before hiding
          }
        });
      }

      handleToolbarVisibility();

      // Add this function to calculate the number of characters that fit in the editor width
      function calculateCharsPerLine() {
        // Get the editor's content width (excluding padding)
        const editorWidth = editor.clientWidth - 30; // Subtract padding

        // Create a temporary span to measure character width
        const temp = document.createElement("span");
        temp.style.cssText = `
			font: ${window.getComputedStyle(editor).font};
			position: absolute;
			visibility: hidden;
			white-space: pre;
		`;
        temp.textContent = "=";
        document.body.appendChild(temp);

        // Calculate how many characters fit
        const charWidth = temp.getBoundingClientRect().width;
        document.body.removeChild(temp);

        // Return the number of characters that will fit
        return Math.floor(editorWidth / charWidth);
      }

      // Add or modify the input event listener
      editor.addEventListener("input", (e) => {
        // Keep existing word count and format handling
        updateWordCount();
        isFormatted = false;
        toggleView();

        // Check for separator pattern
        const pos = editor.selectionStart;
        const content = editor.value;

        if (content.slice(pos - 3, pos) === "===") {
          e.preventDefault(); // Prevent default handling

          // Calculate and create separator
          const numChars = calculateCharsPerLine();
          const separator = "=".repeat(numChars);

          // Replace the typed === with the separator
          const before = content.slice(0, pos - 3);
          const after = content.slice(pos);

          // Add newlines before and after if they're not already there
          const newBefore = before.endsWith("\n") ? before : before + "\n";
          const newAfter = after.startsWith("\n") ? after : "\n" + after;

          // Update content
          editor.value = newBefore + separator + newAfter;

          // Position cursor after separator and newline
          const newPos = newBefore.length + separator.length + 1;
          editor.selectionStart = editor.selectionEnd = newPos;

          console.log("Separator length:", numChars); // Debug info
        }
      });

      // Add window resize handler
      let resizeTimeout;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          const numChars = calculateCharsPerLine();
          const content = editor.value;

          // Update existing separators
          const updatedContent = content.replace(/={20,}/g, (match) => {
            return "=".repeat(numChars);
          });

          if (content !== updatedContent) {
            editor.value = updatedContent;
          }
        }, 100);
      });

      // 3. Add auto-save functionality
      let autoSaveTimeout;
      editor.addEventListener("input", () => {
        clearTimeout(autoSaveTimeout);
        autoSaveTimeout = setTimeout(() => {
          localStorage.setItem("editorContent", editor.value);
        }, 1000);
      });

      // Load saved content
      const savedContent = localStorage.getItem("editorContent");
      if (savedContent) {
        editor.value = savedContent;
        updateWordCount();
      }

      function showStatus(message) {
        const statusBadge = document.getElementById("statusBadge");
        statusBadge.textContent = message;
        statusBadge.classList.add("show");
        setTimeout(() => {
          statusBadge.classList.remove("show");
        }, 2000);
      }

      // Add export functionality
      const exportButton = document.getElementById("exportButton");
      const exportMenu = document.getElementById("exportMenu");
      const exportMd = document.getElementById("exportMd");
      const exportJson = document.getElementById("exportJson");
      const toast = document.getElementById("toast");

      // Toggle export menu
      exportButton.addEventListener("click", (e) => {
        e.stopPropagation();
        exportMenu.classList.toggle("show");

        // Check content type and enable/disable appropriate export options
        const content = editor.value.trim();
        let isJson = false;

        try {
          JSON.parse(content);
          isJson = true;
        } catch (e) {
          isJson = false;
        }

        // Enable/disable export options based on content type
        exportJson.classList.toggle("disabled", !isJson);
        exportMd.classList.toggle("disabled", isJson);
      });

      // Close export menu when clicking outside
      document.addEventListener("click", () => {
        exportMenu.classList.remove("show");
      });

      // Show toast notification
      function showToast(message, duration = 3000) {
        toast.textContent = message;
        toast.classList.add("show");
        setTimeout(() => {
          toast.classList.remove("show");
        }, duration);
      }

      // Export functionality
      function exportContent(content, filename) {
        const blob = new Blob([content], { type: "text/plain" });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
      }

      // Export as Markdown
      exportMd.addEventListener("click", () => {
        const content = editor.value.trim();

        try {
          JSON.parse(content);
          showToast(
            "Content appears to be JSON. Please use JSON export instead."
          );
          return;
        } catch (e) {
          // Content is not JSON, safe to export as MD
          const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
          exportContent(content, `export-${timestamp}.md`);
          showToast("Content exported as Markdown!");
        }
      });

      // Export as JSON
      exportJson.addEventListener("click", () => {
        const content = editor.value.trim();

        try {
          // Try to parse and format JSON
          const parsedJson = JSON.parse(content);
          const formattedJson = JSON.stringify(parsedJson, null, 2);
          const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
          exportContent(formattedJson, `export-${timestamp}.json`);
          showToast("Content exported as formatted JSON!");
        } catch (e) {
          showToast("Invalid JSON content. Please check your JSON syntax.");
        }
      });

      // Add keyboard shortcut for export (Ctrl+Shift+E)
      document.addEventListener("keydown", (e) => {
        if (e.ctrlKey && e.shiftKey && e.key === "E") {
          e.preventDefault();
          exportButton.click();
        }
      });

      // Update export button state based on content changes
      editor.addEventListener("input", () => {
        const content = editor.value.trim();
        let isJson = false;

        try {
          JSON.parse(content);
          isJson = true;
        } catch (e) {
          isJson = false;
        }

        // Update export button state if menu is open
        if (exportMenu.classList.contains("show")) {
          exportJson.classList.toggle("disabled", !isJson);
          exportMd.classList.toggle("disabled", isJson);
        }
      });
    </script>
  </body>
</html>
